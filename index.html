<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#ffffff">
<title>GeoLab v9.6 Ultimate</title>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;700&family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">
<style>
    :root {
        /* Default Variables */
        --bg: #f8fafc;
        --surface: rgba(255, 255, 255, 0.95);
        --border: rgba(0, 0, 0, 0.08);
        --text: #0f172a;
        --primary: #3b82f6;
        --danger: #ef4444;
        --btn-bg: rgba(0,0,0,0.05);
        --btn-text: #0f172a;
        --font-ui: 'Inter', sans-serif;
        --radius: 24px;
        --shadow: 0 10px 40px -10px rgba(0,0,0,0.15);
        --glass-border: 1px solid rgba(255,255,255,0.6);
        --panel-blur: 24px;
    }

    body {
        margin: 0; display: flex; flex-direction: column; align-items: center;
        font-family: var(--font-ui);
        background: var(--bg);
        background-size: 300% 300%; 
        animation: liquidFlow 20s ease infinite;
        background-attachment: fixed;
        color: var(--text);
        height: 100vh; width: 100vw; overflow: hidden;
        touch-action: none; user-select: none; -webkit-user-select: none;
        transition: color 0.3s ease, background 0.3s ease;
    }

    @keyframes liquidFlow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    /* Loading Screen */
    #loading-screen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: var(--bg); z-index: 9999;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 0.5s ease;
    }
    .spinner {
        width: 48px; height: 48px; border: 4px solid rgba(0,0,0,0.1);
        border-bottom-color: var(--primary); border-radius: 50%;
        animation: rot 1s linear infinite; margin-bottom: 20px;
    }
    .loading-brand { font-weight: 800; font-size: 1.2rem; color: var(--text); }
    @keyframes rot { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* Glass Panels */
    .glass-panel {
        background: var(--surface); 
        backdrop-filter: blur(var(--panel-blur)); -webkit-backdrop-filter: blur(var(--panel-blur));
        border: var(--glass-border); box-shadow: var(--shadow);
        transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    /* --- HEADER (FIXED UI) --- */
    header { 
        position: absolute; top: 16px; 
        width: 96%; /* Wider to prevent overflow */
        max-width: 500px; /* Capped width */
        display: flex; justify-content: space-between; align-items: center;
        padding: 6px 10px 6px 16px; /* Tighter padding */
        box-sizing: border-box;
        border-radius: 20px; z-index: 100;
        height: 54px; /* Fixed height to keep it neat */
    }
    .brand-title { font-weight: 800; font-size: 1.1rem; letter-spacing: -0.5px; display: flex; align-items: center; gap: 6px; }
    .dev-badge { background: var(--primary); color: #fff; font-size: 0.6rem; font-weight: 700; padding: 3px 8px; border-radius: 10px; }
    
    .header-actions { display: flex; gap: 6px; }
    .btn-icon-only {
        width: 38px; height: 38px; /* Smaller header buttons */
        border-radius: 12px;
        background: var(--btn-bg); border: none; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        font-size: 1rem; transition: all 0.2s; color: var(--text);
        border: 1px solid var(--border);
    }
    .btn-icon-only:active { transform: scale(0.92); opacity: 0.8; }
    .btn-filled { background: var(--primary); color: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border:none; }

    /* SLIDING VERTICAL TOOLBAR */
    #toolbar {
        position: absolute; top: 50%; left: 16px; 
        transform: translate(-200%, -50%); 
        padding: 6px; border-radius: 20px; 
        display: flex; flex-direction: column; gap: 8px;
        z-index: 90; width: auto;
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    #toolbar.active {
        transform: translate(0, -50%);
    }

    .tool-opt {
        padding: 8px 4px; border-radius: 14px; color: var(--text);
        font-weight: 700; font-size: 0.55rem;
        cursor: pointer;
        transition: all 0.2s; display: flex; flex-direction: column; align-items: center; gap: 4px; 
        opacity: 0.6; width: 44px;
        position: relative; overflow: visible;
    }
    .tool-icon { font-size: 1.2rem; }
    
    .tool-opt:hover { opacity: 0.9; }
    .tool-opt.selected { background: var(--primary); color: #fff; opacity: 1; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transform: scale(1.05); }

    .tool-opt.disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(100%); }
    .tool-opt.disabled:active { transform: none; }
    .lock-badge { position: absolute; top: -4px; right: -4px; font-size: 0.8rem; z-index: 10; pointer-events: none; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1)); }
    
    .tool-opt.disabled:hover::after {
        content: "Disabled"; position: absolute; left: 110%; top: 50%; transform: translateY(-50%);
        background: var(--text); color: var(--bg); padding: 4px 8px; border-radius: 6px; 
        font-size: 0.65rem; font-weight: 700; white-space: nowrap; pointer-events: none;
        animation: fadeIn 0.2s ease; border: 1px solid var(--danger); z-index: 99;
    }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-10px, -50%); } to { opacity: 1; transform: translate(0, -50%); } }

    /* CANVAS */
    #canvas-container {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        border-radius: 40px; 
        background: transparent;
        box-shadow: 0 30px 70px -20px rgba(0, 0, 0, 0.15);
        touch-action: none; overflow: hidden; border: 6px solid var(--surface);
    }
    canvas { display: block; touch-action: none; }

    /* --- CONTROLS (REVAMPED) --- */
    #controls {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 50;
        display: flex; gap: 8px; padding: 6px; 
        border-radius: 20px; /* Tighter container */
    }
    .control-btn {
        border: none; 
        padding: 10px 18px; /* Reduced Size */
        border-radius: 14px; /* "Not that capsule" (Squircle) */
        font-weight: 700; font-size: 0.8rem; cursor: pointer;
        display: flex; align-items: center; gap: 6px; transition: transform 0.1s;
    }
    .btn-ghost { background: var(--btn-bg); color: var(--text); border: 1px solid var(--border); }
    .btn-primary { background: var(--text); color: var(--bg); box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
    .btn-magic { background: var(--primary); color: #fff; box-shadow: 0 8px 20px -5px rgba(0,0,0,0.2); }
    .control-btn:active { transform: scale(0.95); }

    /* POPUP CONFIRMATION */
    .custom-popup {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
        background: var(--surface); padding: 24px; border-radius: 24px;
        width: 85%; max-width: 320px; z-index: 300;
        box-shadow: 0 20px 50px rgba(0,0,0,0.3); border: 1px solid var(--border);
        text-align: center; opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .custom-popup.active { opacity: 1; pointer-events: all; transform: translate(-50%, -50%) scale(1); }
    .popup-title { font-size: 1.2rem; font-weight: 800; margin-bottom: 8px; color: var(--text); }
    .popup-desc { font-size: 0.9rem; opacity: 0.8; margin-bottom: 20px; color: var(--text); }
    .popup-actions { display: flex; gap: 10px; justify-content: center; }
    .popup-btn { flex: 1; padding: 12px; border-radius: 12px; font-weight: 700; border: none; cursor: pointer; }
    .btn-cancel { background: rgba(0,0,0,0.1); color: var(--text); }
    .btn-confirm { background: var(--danger); color: white; }

    /* HUD */
    #debug-hud {
        position: fixed; top: 90px; right: 20px; width: 180px;
        background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.1); border-radius: 16px;
        padding: 15px; font-family: 'JetBrains Mono', monospace; font-size: 10px;
        color: #00ff9d; display: none; z-index: 500; pointer-events: none;
    }
    .hud-row { display: flex; justify-content: space-between; margin-bottom: 4px; border-bottom: 1px dashed rgba(255,255,255,0.1); }

    /* MODAL SYSTEM */
    .modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); backdrop-filter: blur(8px); z-index: 190; display: none;
        opacity: 0; transition: opacity 0.3s;
    }
    .modal-overlay.active { display: block; opacity: 1; }
    
    .bottom-sheet {
        position: fixed; bottom: -100%; left: 50%; transform: translateX(-50%);
        width: 94%; max-width: 500px; background: var(--surface);
        border-top-left-radius: 32px; border-top-right-radius: 32px;
        box-shadow: 0 -20px 60px rgba(0,0,0,0.2); z-index: 200;
        padding: 0; box-sizing: border-box;
        transition: bottom 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        display: flex; flex-direction: column; 
        max-height: 85vh; overflow: hidden;
        border: 1px solid var(--border);
    }
    .bottom-sheet.active { bottom: 0; }

    .sheet-header {
        padding: 24px 24px 10px; display: flex; justify-content: space-between; align-items: center;
        border-bottom: 1px solid var(--border); background: var(--surface); z-index: 10;
    }
    .sheet-title { font-size: 1.5rem; font-weight: 800; letter-spacing: -0.5px; }
    .sheet-content { padding: 20px 24px 40px; overflow-y: auto; }

    /* POINT LIST UI */
    #point-list { display: flex; flex-direction: column; gap: 8px; }
    .point-item {
        display: flex; justify-content: space-between; align-items: center;
        background: var(--surface); padding: 10px 12px 10px 16px; border-radius: 20px;
        border: 1px solid var(--border); transition: all 0.2s;
    }
    .point-left { display: flex; align-items: center; gap: 14px; }
    .point-badge {
        width: 32px; height: 32px; background: var(--primary); color: white;
        border-radius: 10px; display: flex; align-items: center; justify-content: center;
        font-weight: 800; font-size: 0.9rem;
    }
    .point-name { font-weight: 700; color: var(--text); font-size: 0.95rem; }
    .point-controls { display: flex; align-items: center; gap: 14px; }
    .lock-wrapper { display: flex; flex-direction: column; align-items: center; gap: 2px; }
    .lock-label { font-size: 0.6rem; font-weight: 800; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text); }
    .btn-delete {
        width: 38px; height: 38px; border-radius: 12px; border: none;
        background: rgba(239, 68, 68, 0.1); color: var(--danger);
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; font-size: 1rem; transition: all 0.2s;
    }
    .btn-delete:active { background: var(--danger); color: white; transform: scale(0.92); }
    .point-item.locked .point-badge { background: #94a3b8; }
    .point-item.locked .point-name { opacity: 0.6; }

    /* ACCORDION */
    .accordion-item { border: 1px solid var(--border); border-radius: 16px; margin-bottom: 12px; overflow: hidden; background: var(--surface); }
    .accordion-header {
        padding: 16px 20px; font-weight: 700; cursor: pointer; display: flex; justify-content: space-between; align-items: center;
        background: rgba(0,0,0,0.02); transition: background 0.2s;
    }
    .accordion-header:active { background: rgba(0,0,0,0.05); }
    .accordion-body { display: none; padding: 20px; border-top: 1px solid var(--border); }
    .accordion-item.open .accordion-body { display: block; }
    .accordion-item.open .arrow { transform: rotate(180deg); }
    .arrow { transition: transform 0.3s; font-size: 0.8rem; opacity: 0.5; }

    /* UI ELEMENTS */
    .st-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; font-weight: 600; font-size: 0.95rem; }
    .theme-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .theme-btn {
        height: 50px; border-radius: 12px; cursor: pointer;
        border: 2px solid var(--border); background: var(--btn-bg);
        display: flex; align-items: center; justify-content: center; gap: 8px;
        font-size: 0.8rem; font-weight: 700; color: var(--text);
        transition: all 0.2s;
    }
    .theme-btn.active { border-color: var(--primary); background: var(--surface); color: var(--primary); }
    .theme-dot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.1); }

    .switch { position: relative; width: 44px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; inset: 0; background-color: var(--border); border-radius: 34px; transition: .3s; }
    .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: .3s; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    input:checked + .slider { background-color: var(--primary); }
    input:checked + .slider:before { transform: translateX(20px); }
    
    input[type=range] { width: 100%; height: 6px; background: var(--border); border-radius: 10px; accent-color: var(--primary); margin-top: 10px; }
    input[type=number] { width: 50px; padding: 6px; border-radius: 8px; border: 1px solid var(--border); text-align: center; font-weight: 700; font-family: inherit; background: var(--bg); color: var(--text); }

    .btn-close { background: rgba(0,0,0,0.05); border: none; width: 36px; height: 36px; border-radius: 50%; font-size: 1.2rem; cursor: pointer; color: var(--text); display: flex; align-items: center; justify-content: center;}

    .toast {
        position: fixed; top: 100px; left: 50%; transform: translateX(-50%) translateY(-20px);
        background: var(--text); color: var(--bg); padding: 12px 24px;
        border-radius: 30px; font-size: 0.9rem; font-weight: 600; pointer-events: none;
        opacity: 0; transition: all 0.3s; z-index: 300; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

    <div id="loading-screen">
        <div class="spinner"></div>
        <div class="loading-brand">GeoLab v9.6</div>
    </div>

    <div id="confirm-modal" class="custom-popup glass-panel">
        <div class="popup-title">Clear Board?</div>
        <div class="popup-desc">This will remove all points and connections. This action cannot be undone.</div>
        <div class="popup-actions">
            <button class="popup-btn btn-cancel" onclick="closePopup()">Cancel</button>
            <button class="popup-btn btn-confirm" onclick="confirmClear()">Clear All</button>
        </div>
    </div>

    <div id="debug-hud">
        <div class="hud-row"><span>FPS</span><span class="hud-val" id="d-fps">0</span></div>
        <div class="hud-row"><span>PTR</span><span class="hud-val" id="d-mouse">0,0</span></div>
        <div class="hud-row"><span>OBJ</span><span class="hud-val" id="d-obj">0</span></div>
        <div class="hud-row"><span>LNK</span><span class="hud-val" id="d-str">0</span></div>
    </div>

    <header class="glass-panel">
        <div class="brand-title">GeoLab <span class="dev-badge">v9.6</span></div>
        <div class="header-actions">
            <button class="btn-icon-only btn-filled" onclick="toggleToolbar()">üõ†Ô∏è</button>
            <button class="btn-icon-only btn-help" onclick="toggleHelp()">?</button>
            <button class="btn-icon-only" onclick="togglePointsModal()">üìã</button>
            <button class="btn-icon-only" onclick="toggleDebug()">üêû</button>
            <button class="btn-icon-only" onclick="toggleSettings()">‚öôÔ∏è</button>
        </div>
    </header>

    <div id="toolbar" class="glass-panel">
        <div class="tool-opt selected" id="tool-drag" onclick="setTool('drag')"><span class="tool-icon">‚úã</span>Drag</div>
        <div class="tool-opt" id="tool-connect" onclick="setTool('connect')"><span class="tool-icon">üîó</span>Link</div>
        <div class="tool-opt" id="tool-point" onclick="setTool('point')"><span class="tool-icon">üîµ</span>Point</div>
        <div class="tool-opt disabled" id="tool-tangent" onclick="setTool('tangent')">
            <div class="lock-badge">üîí</div>
            <span class="tool-icon">üìê</span>Tan
        </div>
    </div>

    <div id="overlay" class="modal-overlay" onclick="closeAllModals()"></div>

    <div id="help-modal" class="bottom-sheet">
        <div class="sheet-header">
            <span class="sheet-title">How to Use</span>
            <button class="btn-close" onclick="closeAllModals()">√ó</button>
        </div>
        <div class="sheet-content">
            <div class="help-card"><div class="help-icon">‚úã</div><div class="help-text"><h4>Drag Tool</h4><p>Move pins, points, or rotate circles.</p></div></div>
            <div class="help-card"><div class="help-icon">üîó</div><div class="help-text"><h4>Link Tool</h4><p>Connect two points to measure angles.</p></div></div>
            <div class="help-card"><div class="help-icon">üîµ</div><div class="help-text"><h4>Point Tool</h4><p>Tap canvas to create free points.</p></div></div>
            <div class="help-card" style="opacity:0.6"><div class="help-icon">üìê</div><div class="help-text"><h4>Tangent</h4><p>Temporarily Disabled.</p></div></div>
        </div>
    </div>

    <div id="points-modal" class="bottom-sheet">
        <div class="sheet-header">
            <span class="sheet-title">Active Points</span>
            <button class="btn-close" onclick="closeAllModals()">√ó</button>
        </div>
        <div class="sheet-content" id="point-list">
            <div style="text-align:center; opacity:0.5; padding:20px;">No points created yet.</div>
        </div>
    </div>

    <div id="settings-modal" class="bottom-sheet">
        <div class="sheet-header">
            <span class="sheet-title">Settings</span>
            <button class="btn-close" onclick="closeAllModals()">√ó</button>
        </div>
        <div class="sheet-content">
            
            <div class="accordion-item open">
                <div class="accordion-header" onclick="toggleAccordion(this)"><span>Visual Theme</span><span class="arrow">‚ñº</span></div>
                <div class="accordion-body">
                    <div class="theme-grid">
                        <div class="theme-btn" id="th-modern" onclick="selectTheme('modern')"><div class="theme-dot" style="background:#0ea5e9"></div>Ice</div>
                        <div class="theme-btn" id="th-liquid" onclick="selectTheme('liquid')"><div class="theme-dot" style="background:linear-gradient(135deg, #7F00FF, #E100FF)"></div>Liquid</div>
                        <div class="theme-btn" id="th-midnight" onclick="selectTheme('midnight')"><div class="theme-dot" style="background:#0f172a"></div>Night</div>
                        <div class="theme-btn" id="th-blueprint" onclick="selectTheme('blueprint')"><div class="theme-dot" style="background:#2563eb"></div>Blue</div>
                        <div class="theme-btn" id="th-cyber" onclick="selectTheme('cyber')"><div class="theme-dot" style="background:#00ff9d"></div>Cyber</div>
                        <div class="theme-btn" id="th-paper" onclick="selectTheme('paper')"><div class="theme-dot" style="background:#d6d3d1"></div>Paper</div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)"><span>Workspace</span><span class="arrow">‚ñº</span></div>
                <div class="accordion-body">
                    <div class="st-row"><span>Center Hub</span><label class="switch"><input type="checkbox" id="opt-show-center" onchange="updateSettings()"><span class="slider"></span></label></div>
                    <div class="st-row"><span>Ring Protractors</span><label class="switch"><input type="checkbox" id="opt-show-ring" onchange="updateSettings()"><span class="slider"></span></label></div>
                    <div class="st-row"><span>Angle Labels</span><label class="switch"><input type="checkbox" id="opt-always-show" onchange="updateSettings()"><span class="slider"></span></label></div>
                    <div class="st-row"><span>Grid</span><label class="switch"><input type="checkbox" id="opt-show-grid" onchange="updateSettings()"><span class="slider"></span></label></div>
                    <div class="st-row" style="margin-top:10px;"><span>Text Scale: <strong id="lbl-text-scale" style="color:var(--primary)">1.0x</strong></span></div>
                    <input type="range" id="opt-text-scale" min="0.5" max="1.5" step="0.1" value="1.0" oninput="updateSettings()">
                    <div class="st-row" style="margin-top:10px;"><span>Protractors: <strong id="lbl-count" style="color:var(--primary)">8</strong></span></div>
                    <input type="range" id="opt-count" min="4" max="12" step="1" oninput="updateSettings()">
                </div>
            </div>

            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)"><span>Controls</span><span class="arrow">‚ñº</span></div>
                <div class="accordion-body">
                    <div class="st-row"><span>Snap Rotation</span><label class="switch"><input type="checkbox" id="opt-snap-active" onchange="updateSettings()"><span class="slider"></span></label></div>
                    <div class="st-row"><span>Snap (Deg)</span><input type="number" id="opt-snap-val" value="5" min="1" max="90" onchange="updateSettings()"></div>
                    <div class="st-row"><span>Reflex Angles</span><label class="switch"><input type="checkbox" id="opt-reflex" onchange="updateSettings()"><span class="slider"></span></label></div>
                    <div class="st-row"><span>Show Hitboxes</span><label class="switch"><input type="checkbox" id="opt-show-hitboxes" onchange="updateSettings()"><span class="slider"></span></label></div>
                </div>
            </div>

            <button style="background:#fee2e2; color:#b91c1c; width:100%; padding:14px; border:none; border-radius:16px; font-weight:700; margin-top:20px;" onclick="resetSettings()">Reset App</button>
        </div>
    </div>

    <div id="canvas-container"><canvas id="geoCanvas"></canvas></div>
    
    <div id="controls" class="glass-panel">
        <button class="control-btn btn-ghost" onclick="requestClear()">Clear</button>
        <button class="control-btn btn-primary" onclick="resetBoard()">Reset</button>
        <button class="control-btn btn-magic" onclick="autoAlign()">‚ú® Align</button>
    </div>

    <div class="toast" id="toast">Action Saved</div>

<script>
    // --- THEME ENGINE ---
    const THEMES = {
        'modern': { 
            bg: '#f0f9ff', transparentCanvas: false, c_bg: '#f0f9ff', 
            surface: 'rgba(255, 255, 255, 0.95)', 
            text: '#0c4a6e', primary: '#0ea5e9', border: 'rgba(14, 165, 233, 0.2)', 
            btn_bg: 'rgba(255,255,255,0.6)', btn_text: '#0f172a',
            c_grid: '#e0f2fe', c_line: '#0284c7', c_text: '#0c4a6e', c_pin: '#0ea5e9', 
            font: "'Inter', sans-serif", blur:'24px' 
        },
        'liquid': { 
            bg: 'radial-gradient(at 0% 0%, hsla(280,100%,20%,1) 0, transparent 50%), radial-gradient(at 50% 0%, hsla(240,100%,30%,1) 0, transparent 50%), radial-gradient(at 100% 0%, hsla(320,100%,30%,1) 0, transparent 50%), radial-gradient(at 0% 50%, hsla(340,100%,30%,1) 0, transparent 50%), radial-gradient(at 100% 50%, hsla(260,100%,20%,1) 0, transparent 50%), #0f0c29', 
            transparentCanvas: true, c_bg: 'rgba(255, 255, 255, 0)', surface: 'rgba(0, 0, 0, 0.4)', 
            text: '#ffffff', primary: '#00d2ff', border: 'rgba(255, 255, 255, 0.3)', 
            btn_bg: 'rgba(255,255,255,0.1)', btn_text: '#ffffff',
            c_grid: 'rgba(255, 255, 255, 0.1)', c_line: '#00d2ff', c_text: '#ffffff', c_pin: '#00d2ff', 
            font: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif", blur:'30px'
        },
        'midnight': { 
            bg: '#020617', transparentCanvas: false, c_bg: '#020617', 
            surface: 'rgba(15, 23, 42, 0.95)', text: '#f1f5f9', primary: '#38bdf8', 
            border: 'rgba(255,255,255,0.15)', btn_bg: 'rgba(255,255,255,0.1)', btn_text: '#ffffff',
            c_grid: '#1e293b', c_line: '#38bdf8', c_text: '#e2e8f0', c_pin: '#0ea5e9', 
            font: "'Inter', sans-serif", blur:'24px' 
        },
        'blueprint': { 
            bg: '#172554', transparentCanvas: false, c_bg: '#172554', 
            surface: 'rgba(30, 58, 138, 0.95)', text: '#dbeafe', primary: '#60a5fa', 
            border: 'rgba(255,255,255,0.2)', btn_bg: 'rgba(255,255,255,0.1)', btn_text: '#ffffff',
            c_grid: 'rgba(255,255,255,0.1)', c_line: '#93c5fd', c_text: '#dbeafe', c_pin: '#3b82f6', 
            font: "'Space Grotesk', sans-serif", blur:'24px' 
        },
        'cyber': { bg: '#000000', transparentCanvas: false, c_bg: '#000000', surface: 'rgba(10,10,10,0.9)', text: '#00ff9d', primary: '#00ff9d', border: '#00ff9d', btn_bg: 'rgba(0,255,157,0.1)', btn_text:'#00ff9d', c_grid: 'rgba(0,255,157,0.1)', c_line: '#00ff9d', c_text: '#00ff9d', c_pin: '#ffffff', font: "'JetBrains Mono', monospace", blur:'24px' },
        'paper': { bg: '#f5f5f4', transparentCanvas: false, c_bg: '#f5f5f4', surface: 'rgba(255,255,255,0.9)', text: '#292524', primary: '#ea580c', border: 'rgba(0,0,0,0.1)', btn_bg: 'rgba(0,0,0,0.05)', btn_text:'#292524', c_grid: 'rgba(0,0,0,0.05)', c_line: '#44403c', c_text: '#292524', c_pin: '#ea580c', font: "'Crimson Pro', serif", blur:'24px' }
    };

    function getCheck(id) { const el = document.getElementById(id); return el ? el.checked : false; }
    function getVal(id) { const el = document.getElementById(id); return el ? el.value : ""; }
    function showToast(msg) { const t = document.getElementById('toast'); t.innerText = msg; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2000); }
    function drawRoundRect(ctx, x, y, w, h, r) { if (ctx.roundRect) ctx.roundRect(x, y, w, h, r); else { if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2; ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); } }

    const canvas = document.getElementById('geoCanvas');
    const ctx = canvas.getContext('2d');

    const DEFAULTS = { currentTheme: 'modern', showGrid: true, showCenter: true, showRing: true, alwaysShowAngles: true, snapRotation: false, snapIncrement: 5, showHitboxes: false, textScale: 1.0, protractorCount: 8, strictPhysics: true };
    let appSettings = {...DEFAULTS};
    try { const s=JSON.parse(localStorage.getItem('geoSettings')); if(s) appSettings={...DEFAULTS,...s}; } catch(e){}
    if(!THEMES[appSettings.currentTheme]) appSettings.currentTheme='modern';

    let debugMode = false;
    let lastTime = 0, frameCount = 0, fps = 0, ptrX=0, ptrY=0, lastPos={x:0,y:0}, renderTime=0;
    
    let currentTool = 'drag'; 
    let freePoints = []; 
    let uniquePointID = 2000;
    let tangents = []; 
    let tangentStep = 0; 
    let tangentSourceID = null;
    let protractors = [], strings = [];
    let draggingProtractor = null, draggingPoint = null, dragOffsetAngle = 0, activeStringStartID = null, hoveredPinID = null;
    let dragPointOffset = {x:0, y:0};

    let boardRadius, protractorRadius, centerProtractorRadius;
    let width, height, centerX, centerY;
    const CENTER_ID = 999;
    let centerObj = { id: CENTER_ID, angle: 0, pivotX: 0, pivotY: 0, r: 0 };

    // --- POPUP LOGIC ---
    function requestClear() {
        if(strings.length === 0 && freePoints.length === 0 && tangents.length === 0) { showToast("Board is empty"); return; }
        document.getElementById('overlay').classList.add('active');
        document.getElementById('confirm-modal').classList.add('active');
    }
    function closePopup() {
        document.getElementById('confirm-modal').classList.remove('active');
        document.getElementById('overlay').classList.remove('active');
    }
    function confirmClear() {
        strings = []; freePoints = []; tangents = [];
        closePopup(); draw(); showToast("Board Cleared");
    }

    function toggleAccordion(header) { const item = header.parentElement; item.classList.toggle('open'); }
    function toggleDebug() { debugMode = !debugMode; document.getElementById('debug-hud').style.display = debugMode ? 'block' : 'none'; draw(); }
    
    function toggleToolbar() { document.getElementById('toolbar').classList.toggle('active'); }

    function closeAllModals() {
        document.querySelectorAll('.bottom-sheet').forEach(el => el.classList.remove('active'));
        document.getElementById('overlay').classList.remove('active');
        document.getElementById('confirm-modal').classList.remove('active');
    }
    function openModal(id) { closeAllModals(); document.getElementById(id).classList.add('active'); document.getElementById('overlay').classList.add('active'); }
    function toggleHelp() { openModal('help-modal'); }
    function toggleSettings() { openModal('settings-modal'); }
    function togglePointsModal() { renderPointList(); openModal('points-modal'); }

    function setTool(t) {
        if (t === 'tangent') return;
        currentTool = t;
        document.querySelectorAll('.tool-opt').forEach(el => el.classList.remove('selected'));
        document.getElementById('tool-'+t).classList.add('selected');
        tangentStep = 0; tangentSourceID = null;
        showToast("Tool: " + t.charAt(0).toUpperCase() + t.slice(1));
    }

    function renderPointList() {
        const list = document.getElementById('point-list');
        list.innerHTML = "";
        if(freePoints.length === 0) { list.innerHTML = `<div style="text-align:center; opacity:0.5; padding:20px;">No points created.</div>`; return; }
        freePoints.forEach(p => {
            const row = document.createElement('div');
            row.className = `point-item ${p.locked ? 'locked' : ''}`;
            row.innerHTML = `
                <div class="point-left"><div class="point-badge">${p.label}</div><span class="point-name">Point ${p.label}</span></div>
                <div class="point-controls">
                    <div class="lock-wrapper"><span class="lock-label">Lock</span><label class="switch"><input type="checkbox" ${p.locked ? 'checked' : ''} onchange="togglePointLock(${p.id})"><span class="slider"></span></label></div>
                    <button class="btn-delete" onclick="deletePoint(${p.id})">‚úï</button>
                </div>`;
            list.appendChild(row);
        });
    }

    function togglePointLock(id) { const p = freePoints.find(pt => pt.id === id); if(p) { p.locked = !p.locked; renderPointList(); draw(); } }
    function deletePoint(id) {
        if(confirm("Delete this point?")) {
            freePoints = freePoints.filter(p => p.id !== id);
            strings = strings.filter(s => s.start !== id && s.end !== id);
            tangents = tangents.filter(t => t.sourceID !== id && t.targetID !== id);
            freePoints.forEach((p, index) => { p.label = String.fromCharCode(65 + (index % 26)); });
            renderPointList(); draw(); showToast("Point Deleted");
        }
    }

    function selectTheme(name) { appSettings.currentTheme = name; updateSettings(); applyTheme(); }

    function applyTheme() {
        const t = THEMES[appSettings.currentTheme] || THEMES['modern'];
        const r = document.querySelector(':root');
        
        r.style.setProperty('--bg', t.bg); 
        r.style.setProperty('--surface', t.surface); 
        r.style.setProperty('--text', t.text);
        r.style.setProperty('--primary', t.primary); 
        r.style.setProperty('--border', t.border); 
        r.style.setProperty('--font-ui', t.font);
        r.style.setProperty('--panel-blur', t.blur);
        r.style.setProperty('--btn-bg', t.btn_bg || 'rgba(0,0,0,0.05)');
        r.style.setProperty('--btn-text', t.btn_text || t.text);
        
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('th-' + appSettings.currentTheme);
        if(btn) btn.classList.add('active');
        
        document.body.style.background = t.bg;
        document.body.style.backgroundSize = "300% 300%"; 
        
        if(appSettings.currentTheme === 'liquid') document.body.classList.add('liquid-mode');
        else document.body.classList.remove('liquid-mode');
        
        draw();
    }

    function updateSettings() { 
        appSettings.alwaysShowAngles = getCheck('opt-always-show'); 
        appSettings.showGrid = getCheck('opt-show-grid'); 
        appSettings.snapRotation = getCheck('opt-snap-active');
        appSettings.snapIncrement = parseInt(getVal('opt-snap-val')) || 5;
        appSettings.strictPhysics = !getCheck('opt-reflex');
        appSettings.textScale = parseFloat(getVal('opt-text-scale')) || 1.0; 
        appSettings.showCenter = getCheck('opt-show-center'); 
        appSettings.showRing = getCheck('opt-show-ring');
        appSettings.showHitboxes = getCheck('opt-show-hitboxes');
        document.getElementById('lbl-text-scale').innerText = appSettings.textScale + "x";
        document.getElementById('lbl-count').innerText = parseInt(getVal('opt-count')) || 8;
        const newCount = parseInt(getVal('opt-count')) || 8; 
        if (newCount !== appSettings.protractorCount) { appSettings.protractorCount = newCount; initProtractors(); } 
        localStorage.setItem('geoSettings', JSON.stringify(appSettings)); 
        applyTheme();
    }

    function resetSettings() { if(confirm("Reset Everything?")) { appSettings = {...DEFAULTS}; localStorage.setItem('geoSettings', JSON.stringify(appSettings)); initUI(); strings=[]; freePoints=[]; tangents=[]; initProtractors(); closeAllModals(); } }
    function resetBoard() { strings = []; freePoints = []; tangents = []; autoAlign(); draw(); showToast("Reset"); }

    function initUI() { 
        try { 
            setTimeout(()=>{var s=document.getElementById('loading-screen');if(s){s.style.opacity='0';setTimeout(()=>{if(s)s.style.display='none';},600);}},1000);
            document.getElementById('opt-always-show').checked = appSettings.alwaysShowAngles; 
            document.getElementById('opt-show-grid').checked = appSettings.showGrid; 
            document.getElementById('opt-snap-active').checked = appSettings.snapRotation;
            document.getElementById('opt-snap-val').value = appSettings.snapIncrement;
            document.getElementById('opt-reflex').checked = !appSettings.strictPhysics; 
            document.getElementById('opt-show-center').checked = appSettings.showCenter; 
            document.getElementById('opt-show-ring').checked = appSettings.showRing;
            document.getElementById('opt-show-hitboxes').checked = appSettings.showHitboxes;
            document.getElementById('lbl-text-scale').innerText = appSettings.textScale + "x"; 
            document.getElementById('opt-text-scale').value = appSettings.textScale;
            document.getElementById('opt-count').value = appSettings.protractorCount;
            document.getElementById('lbl-count').innerText = appSettings.protractorCount;
            applyTheme();
        } catch(e) {} 
    }

    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        const dpr = Math.min(window.devicePixelRatio || 2, 3);
        const cw = Math.min(width * 0.95, 800); const ch = Math.min(height * 0.75, 900);
        canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
        canvas.width = cw * dpr; canvas.height = ch * dpr; 
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(dpr, dpr); 
        width = cw; height = ch; centerX = width / 2; centerY = height / 2;
        const min = Math.min(width, height); 
        centerProtractorRadius = min * 0.15;
        centerObj.pivotX = centerX; centerObj.pivotY = centerY; centerObj.r = centerProtractorRadius;
        boardRadius = min * 0.38; protractorRadius = min * 0.12;
        if (protractors.length !== appSettings.protractorCount) initProtractors();
        draw();
    }

    class HalfProtractor {
        constructor(id, ang) { this.id = id; this.angle = ang; }
        draw(ctx, t) {
            const theta = (this.id / appSettings.protractorCount) * Math.PI * 2 - (Math.PI/2);
            this.pivotX = centerX + boardRadius * Math.cos(theta); this.pivotY = centerY + boardRadius * Math.sin(theta); this.r = protractorRadius;
            
            if (appSettings.showRing) {
                ctx.save(); ctx.translate(this.pivotX, this.pivotY); ctx.rotate(this.angle); 
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI, false); ctx.closePath();
                const g = ctx.createLinearGradient(0, -this.r, 0, 0); 
                if (t.transparentCanvas) { g.addColorStop(0, 'rgba(255,255,255,0.1)'); g.addColorStop(1, 'rgba(255,255,255,0.4)'); } 
                else { g.addColorStop(0, t.c_bg); g.addColorStop(1, t.surface); }
                ctx.fillStyle = g; ctx.fill(); ctx.lineWidth = 1.5; ctx.strokeStyle = t.c_line; ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-this.r, 0); ctx.lineTo(this.r, 0); ctx.stroke(); 
                this.drawScale(ctx, this.r, t); ctx.restore(); 
            }
            if(appSettings.showHitboxes || debugMode) { ctx.beginPath(); ctx.arc(this.pivotX, this.pivotY, this.r, 0, Math.PI*2); ctx.fillStyle = "rgba(255,0,0,0.1)"; ctx.fill(); ctx.strokeStyle = "rgba(255,0,0,0.5)"; ctx.stroke(); }
            this.drawPin(ctx, t);
        }
        drawScale(ctx, r, t) {
            ctx.textAlign = "center"; ctx.textBaseline = "middle"; const scale = appSettings.textScale || 1.0;
            const fs = Math.max(9, r * 0.13) * scale; ctx.font = `600 ${fs}px ${t.font.split(',')[0]}`; ctx.fillStyle = t.c_text;
            for (let i = 0; i <= 180; i++) { 
                const rad = (i*Math.PI)/180; const c = Math.cos(rad); const s = Math.sin(rad); 
                let l = 0; if (i%30===0) l = r*0.15; else if (i%10===0) l = r*0.10;
                if (l>0) { ctx.beginPath(); ctx.moveTo(r*c, r*s); ctx.lineTo((r-l)*c, (r-l)*s); ctx.lineWidth = (i%30===0)?1.5:0.5; ctx.strokeStyle = t.c_line; ctx.stroke(); }
                if (i % 45 === 0) { const td = r*0.65; ctx.save(); ctx.translate(td*c, td*s); ctx.rotate(rad + Math.PI/2); ctx.fillText(i, 0, 0); ctx.restore(); } 
            }
        }
        drawPin(ctx, t) { 
            ctx.beginPath(); ctx.arc(this.pivotX, this.pivotY, this.r * 0.08, 0, Math.PI * 2); ctx.fillStyle = t.c_pin; ctx.fill(); ctx.strokeStyle = t.c_bg; ctx.lineWidth = 2; ctx.stroke(); 
            if (hoveredPinID === this.id || activeStringStartID === this.id) { ctx.beginPath(); ctx.arc(this.pivotX, this.pivotY, this.r * 0.25, 0, Math.PI * 2); ctx.fillStyle = t.primary; ctx.globalAlpha=0.2; ctx.fill(); ctx.globalAlpha=1.0; } 
        }
    }
    
    function initProtractors() { protractors = []; for (let i = 0; i < appSettings.protractorCount; i++) { const theta = (i / appSettings.protractorCount) * Math.PI * 2 - (Math.PI/2); protractors.push(new HalfProtractor(i, theta + Math.PI/2)); } }

    function drawCenterProtractor(ctx, t) {
        ctx.save(); ctx.translate(centerX, centerY); const r = centerProtractorRadius;
        if(appSettings.showCenter) {
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fillStyle = t.transparentCanvas ? 'rgba(255,255,255,0.1)' : t.c_bg; ctx.fill(); ctx.strokeStyle = t.c_line; ctx.lineWidth = 2; ctx.stroke();
            const scale = appSettings.textScale || 1.0; ctx.font = `600 ${Math.max(9, r * 0.09) * scale}px ${t.font.split(',')[0]}`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = t.c_text;
            for (let i = 0; i < 360; i+=15) { 
                const rad = (i*Math.PI)/180; const c = Math.cos(rad); const s = Math.sin(rad); 
                const l = (i%30===0)? r*0.12 : r*0.06; 
                ctx.beginPath(); ctx.moveTo(r*c, r*s); ctx.lineTo((r-l)*c, (r-l)*s); ctx.strokeStyle = t.c_text; ctx.stroke(); 
                if (i % 45 === 0) { const tr = r * 0.70; ctx.fillText(i, tr*c, tr*s); } 
            }
        }
        if(appSettings.showHitboxes || debugMode) { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fillStyle = "rgba(0,0,255,0.1)"; ctx.fill(); ctx.strokeStyle = "rgba(0,0,255,0.5)"; ctx.stroke(); }
        const isHover = (hoveredPinID===CENTER_ID||activeStringStartID===CENTER_ID);
        ctx.beginPath(); ctx.arc(0, 0, r*0.15, 0, Math.PI*2); ctx.fillStyle = isHover ? t.primary : t.c_pin; ctx.fill(); ctx.strokeStyle=t.c_bg; ctx.lineWidth=3; ctx.stroke();
        if (isHover) { ctx.beginPath(); ctx.arc(0, 0, r*0.35, 0, Math.PI*2); ctx.fillStyle=t.primary; ctx.globalAlpha=0.2; ctx.fill(); ctx.globalAlpha=1.0; } 
        ctx.restore();
    }

    function drawFreePoints(ctx, t) {
        freePoints.forEach((p, idx) => {
            const isHover = (hoveredPinID === p.id || activeStringStartID === p.id || draggingPoint === p);
            ctx.beginPath(); ctx.arc(p.x, p.y, isHover ? 9 : 6, 0, Math.PI*2);
            if(p.locked) ctx.fillStyle = "#94a3b8"; else ctx.fillStyle = t.primary;
            ctx.fill(); ctx.strokeStyle = t.transparentCanvas ? 'rgba(255,255,255,0.5)' : t.c_bg; ctx.lineWidth = 2; ctx.stroke();
            if(isHover && !p.locked) { ctx.beginPath(); ctx.arc(p.x, p.y, 14, 0, Math.PI*2); ctx.fillStyle=t.primary; ctx.globalAlpha=0.2; ctx.fill(); ctx.globalAlpha=1.0; }
            ctx.font = `bold 12px ${t.font.split(',')[0]}`; ctx.fillStyle = t.c_text; ctx.fillText(p.label, p.x + 12, p.y - 12);
        });
    }

    function getPinPos(id) {
        if (id === CENTER_ID) return {x:centerX, y:centerY, r:centerProtractorRadius, angle:0}; 
        if (id < 100) return {x: protractors[id].pivotX, y: protractors[id].pivotY, r:protractors[id].r, angle:0};
        const fp = freePoints.find(p => p.id === id); return fp ? {x:fp.x, y:fp.y, r:0, angle:0} : {x:0, y:0, r:0, angle:0};
    }

    function getAllConnectedAngles(pid) {
        let angs = []; const origin = getPinPos(pid);
        const halfCount = appSettings.protractorCount / 2;
        strings.forEach(s => { 
            let targetID; 
            if (s.start === pid) targetID = s.end; else if (s.end === pid) targetID = s.start; 
            if (pid === CENTER_ID && Math.abs(s.start - s.end) === halfCount) {
                let pStart = protractors[s.start]; let pEnd = protractors[s.end];
                let ang1 = Math.atan2(pStart.pivotY - centerY, pStart.pivotX - centerX); if(ang1 < 0) ang1 += Math.PI*2; angs.push(ang1);
                let ang2 = Math.atan2(pEnd.pivotY - centerY, pEnd.pivotX - centerX); if(ang2 < 0) ang2 += Math.PI*2; angs.push(ang2);
            }
            if (targetID !== undefined) { 
                const tPos = getPinPos(targetID);
                let a = Math.atan2(tPos.y - origin.y, tPos.x - origin.x); if (a < 0) a += Math.PI * 2; angs.push(a); 
            } 
        });
        return [...new Set(angs.map(a => parseFloat(a.toFixed(5))))].sort((a,b) => a-b);
    }

    function drawReadings(ctx, t) { 
        protractors.forEach(p => { 
            if (!appSettings.alwaysShowAngles && p.id !== hoveredPinID && p.id !== activeStringStartID && draggingProtractor !== p) return; 
            const angs = getAllConnectedAngles(p.id); let rels = []; 
            angs.forEach(a => { let r = a - p.angle; r %= (Math.PI*2); if (r<0) r+=Math.PI*2; if (!appSettings.strictPhysics || r <= Math.PI+0.001) rels.push(r); }); rels.sort((a,b)=>a-b); 
            if (rels.length === 1) drawWedge(ctx, p, 0, rels[0], t); else if (rels.length >= 2) for(let i=0; i<rels.length-1; i++) drawWedge(ctx, p, rels[i], rels[i+1], t); 
        }); 
        if (appSettings.showCenter && (appSettings.alwaysShowAngles || hoveredPinID === CENTER_ID || activeStringStartID === CENTER_ID)) { 
            const cAngs = getAllConnectedAngles(CENTER_ID); if (cAngs.length >= 2) for(let i=0; i<cAngs.length; i++) { let d = cAngs[(i+1)%cAngs.length] - cAngs[i]; if(d<0) d+=Math.PI*2; if(d<=Math.PI) drawWedge(ctx, centerObj, cAngs[i], cAngs[(i+1)%cAngs.length], t); } 
        }
        freePoints.forEach(p => {
             if (!appSettings.alwaysShowAngles && p.id !== hoveredPinID && p.id !== activeStringStartID) return; 
             const angs = getAllConnectedAngles(p.id);
             if (angs.length >= 2) { 
                 for(let i=0; i<angs.length; i++) { 
                     let d = angs[(i+1)%angs.length] - angs[i]; if(d < 0) d += Math.PI*2; 
                     if(d <= Math.PI) { let tempObj = { pivotX: p.x, pivotY: p.y, r: 45, angle: 0 }; drawWedge(ctx, tempObj, angs[i], angs[(i+1)%angs.length], t); }
                 } 
             }
        });
    }

    function drawWedge(ctx, p, s, e, t) { 
        let d = e - s; if(d<0) d+=Math.PI*2; let deg = (d * (180 / Math.PI)).toFixed(1); if(parseFloat(deg) < 0.2) return;
        ctx.save(); ctx.translate(p.pivotX, p.pivotY); ctx.rotate(p.angle); 
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,p.r,s,e); ctx.closePath(); ctx.fillStyle = t.primary; ctx.globalAlpha = 0.15; ctx.fill(); ctx.globalAlpha = 1.0;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(p.r*Math.cos(s), p.r*Math.sin(s)); ctx.strokeStyle=t.primary; ctx.lineWidth=2; ctx.setLineDash([2,2]); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(p.r*Math.cos(e), p.r*Math.sin(e)); ctx.stroke(); ctx.setLineDash([]); 
        if(parseFloat(deg)>2) { 
            let diff = e - s; if (diff < 0) diff += Math.PI * 2; let mid = s + diff / 2;
            const dist = p.r * 0.65;
            ctx.translate(dist*Math.cos(mid), dist*Math.sin(mid)); ctx.rotate(-p.angle); 
            let lbl = deg+"¬∞"; 
            const scale = appSettings.textScale || 1.0;
            const w = ctx.measureText(lbl).width + (14 * scale);
            ctx.fillStyle = t.transparentCanvas ? 'rgba(255,255,255,0.7)' : t.c_bg; 
            ctx.shadowColor="rgba(0,0,0,0.1)"; ctx.shadowBlur=4;
            ctx.beginPath(); drawRoundRect(ctx, -w/2, -12, w, 24, 8); ctx.fill(); ctx.shadowBlur=0;
            ctx.fillStyle = t.text; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font = `bold ${12*scale}px ${t.font.split(',')[0]}`; ctx.fillText(lbl, 0, 1); 
        } 
        ctx.restore(); 
    }
    
    function updateDebug() {
        if(!debugMode) return;
        const now = performance.now(); frameCount++;
        if(now - lastTime >= 1000) { fps = frameCount; frameCount=0; lastTime=now; }
        document.getElementById('d-fps').innerText = fps;
        document.getElementById('d-mouse').innerText = Math.round(ptrX)+","+Math.round(ptrY);
        document.getElementById('d-obj').innerText = freePoints.length + "P / " + protractors.length + "R";
        document.getElementById('d-str').innerText = strings.length;
    }

    function autoAlign() { protractors.forEach(p => { const angs = getAllConnectedAngles(p.id); if (angs.length > 0) { if (angs.length === 1) p.angle = angs[0]; else { let maxG = 0, best = angs[0]; for (let i=0; i<angs.length; i++) { let g = angs[(i+1)%angs.length] - angs[i]; if(g<0) g+=Math.PI*2; if(g>maxG) { maxG=g; best=angs[(i+1)%angs.length]; } } p.angle=best; } } }); draw(); }

    function draw() { 
        const start = performance.now();
        if (!THEMES[appSettings.currentTheme]) appSettings.currentTheme = 'modern';
        const t = THEMES[appSettings.currentTheme]; 
        
        ctx.clearRect(0,0,width,height); 
        
        if(appSettings.showGrid) {
            ctx.fillStyle = t.c_grid; ctx.strokeStyle = t.c_grid;
            if(t.gridType === 'dots') { for(let x=20; x<width; x+=30) for(let y=20; y<height; y+=30) { ctx.beginPath(); ctx.arc(x,y,1,0,Math.PI*2); ctx.fill(); } } 
            else { ctx.lineWidth = 1; ctx.beginPath(); for(let x=0; x<width; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,height); } for(let y=0; y<height; y+=40) { ctx.moveTo(0,y); ctx.lineTo(width,y); } ctx.stroke(); }
        }
        ctx.shadowBlur = t.glow; ctx.shadowColor = t.primary;
        drawCenterProtractor(ctx, t);
        protractors.forEach(p=>p.draw(ctx, t)); 
        drawFreePoints(ctx, t);
        ctx.shadowBlur = 0; ctx.lineCap='round'; 
        strings.forEach(l => { 
            if(!appSettings.showCenter && (l.start === CENTER_ID || l.end === CENTER_ID)) return;
            const p1 = getPinPos(l.start); const p2 = getPinPos(l.end); 
            if(!p1 || !p2) return;
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineWidth=4; ctx.strokeStyle=t.c_bg; ctx.stroke(); ctx.strokeStyle=t.c_line; ctx.lineWidth=3; ctx.stroke(); 
        }); 
        ctx.shadowBlur = t.glow; ctx.shadowColor = t.primary;
        drawReadings(ctx, t); 
        if((activeStringStartID!==null) && lastPos) { 
            const startID = activeStringStartID;
            const p1 = getPinPos(startID);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(lastPos.x, lastPos.y); ctx.strokeStyle=t.c_line; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]); 
        } 
        updateDebug();
    }

    function getPointer(e) { const r = canvas.getBoundingClientRect(); const cx = e.touches?e.touches[0].clientX:e.clientX; const cy = e.touches?e.touches[0].clientY:e.clientY; return (r.width===0)?{x:0,y:0}:{x:(cx-r.left)*(width/r.width), y:(cy-r.top)*(height/r.height)}; }
    function getIDAt(x,y) { 
        for(let p of freePoints) { if(Math.hypot(x - p.x, y - p.y) < 20) return p.id; }
        if(Math.hypot(x-centerX, y-centerY) < centerProtractorRadius * 0.4) return CENTER_ID; 
        for(let p of protractors) if(Math.hypot(x-p.pivotX, y-p.pivotY) < protractorRadius * 0.4) return p.id; 
        return null; 
    }
    function checkCircleHit(x,y) { 
        for(let i=protractors.length-1; i>=0; i--) if(Math.hypot(x-protractors[i].pivotX, y-protractors[i].pivotY)<protractors[i].r) return protractors[i].id;
        if(appSettings.showCenter && Math.hypot(x-centerX, y-centerY) < centerObj.r) return CENTER_ID;
        return null; 
    }

    canvas.addEventListener('mousedown', e => { 
        if(e.cancelable) e.preventDefault(); 
        const p = getPointer(e); lastPos=p; ptrX=p.x; ptrY=p.y; 
        let idHit = getIDAt(p.x, p.y);
        let circleHitID = checkCircleHit(p.x, p.y);
        if (currentTool === 'point') { 
            const label = String.fromCharCode(65 + (freePoints.length % 26)); 
            freePoints.push({id: uniquePointID++, x: p.x, y: p.y, locked: false, label: label}); 
            draw(); showToast("Point Created"); return; 
        }
        if (currentTool === 'drag') {
            if (idHit !== null && idHit >= 2000) {
                const point = freePoints.find(fp => fp.id === idHit);
                if (point) { if (!point.locked) { draggingPoint = point; dragPointOffset = {x: point.x - p.x, y: point.y - p.y}; } else { showToast("Point Locked"); } }
                return;
            }
            if(circleHitID !== null && circleHitID < 100) {
                draggingProtractor = protractors[circleHitID];
                const dx=p.x-draggingProtractor.pivotX; const dy=p.y-draggingProtractor.pivotY; 
                dragOffsetAngle=draggingProtractor.angle-Math.atan2(dy,dx);
                return;
            }
        }
        if (currentTool === 'connect') { if(idHit!==null) { activeStringStartID=idHit; draw(); return; } }
    });
    
    canvas.addEventListener('mousemove', e => { 
        if(e.cancelable) e.preventDefault(); 
        const p = getPointer(e); lastPos=p; ptrX=p.x; ptrY=p.y;
        const id = getIDAt(p.x, p.y); if(id!==hoveredPinID) { hoveredPinID=id; if(!draggingProtractor && !draggingPoint) draw(); } 
        if(activeStringStartID!==null) draw(); 
        else if(draggingPoint) { draggingPoint.x = p.x + dragPointOffset.x; draggingPoint.y = p.y + dragPointOffset.y; draw(); }
        else if(draggingProtractor) { 
            const dx=p.x-draggingProtractor.pivotX; const dy=p.y-draggingProtractor.pivotY; 
            let rawAngle=Math.atan2(dy,dx)+dragOffsetAngle; 
            if (appSettings.snapRotation) { const s = (appSettings.snapIncrement || 5) * (Math.PI/180); rawAngle=Math.round(rawAngle/s)*s; } 
            draggingProtractor.angle=rawAngle; draw(); 
        } 
    });
    
    window.addEventListener('mouseup', e => { 
        if(activeStringStartID!==null) { 
            const end = getIDAt(lastPos.x, lastPos.y); 
            if(end!==null && end!==activeStringStartID) { 
                const exists = strings.some(s=>(s.start===activeStringStartID && s.end===end)||(s.start===end && s.end===activeStringStartID)); 
                if(!exists) { 
                    strings.push({start:activeStringStartID, end:end}); 
                    showToast("Connected");
                    
                    // --- NEW LOGIC: AUTO-ALIGN HIDDEN RINGS ONLY ---
                    if (!appSettings.showRing) {
                        [activeStringStartID, end].forEach(pid => {
                            if (pid < 100 && pid !== CENTER_ID) { // Check if it is a protractor
                                const p = protractors[pid];
                                const angs = getAllConnectedAngles(p.id);
                                if (angs.length > 0) {
                                    if (angs.length === 1) p.angle = angs[0];
                                    else {
                                        let maxG = 0, best = angs[0];
                                        for (let i=0; i<angs.length; i++) {
                                            let g = angs[(i+1)%angs.length] - angs[i];
                                            if(g<0) g+=Math.PI*2;
                                            if(g>maxG) { maxG=g; best=angs[(i+1)%angs.length]; }
                                        }
                                        p.angle = best;
                                    }
                                }
                            }
                        });
                    }
                    // --- END NEW LOGIC ---
                } 
            } 
            activeStringStartID=null; draw(); 
        } 
        draggingProtractor=null; draggingPoint=null;
    });

    // --- FIX FOR DOUBLE POINT CREATION ---
    // We prevent default on touchstart to stop the browser from firing a backup 'mousedown'
    canvas.addEventListener('touchstart', e => { 
        if(e.cancelable) e.preventDefault(); 
        const touch = e.touches[0];
        const me = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY, bubbles: true });
        canvas.dispatchEvent(me); 
    }, {passive:false});

    canvas.addEventListener('touchmove', e => { 
        if(e.cancelable) e.preventDefault(); 
        const touch = e.touches[0];
        const me = new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY, bubbles: true });
        canvas.dispatchEvent(me); 
    }, {passive:false});

    window.addEventListener('touchend', e => { 
        const me = new MouseEvent('mouseup', { bubbles: true });
        window.dispatchEvent(me); 
    });

    window.onload = function() { initUI(); resize(); setTimeout(() => { const s = document.getElementById('loading-screen'); if(s){s.style.opacity='0';setTimeout(()=>{s.style.display='none';},600);} }, 1000); }; 
    window.onresize = resize;
</script>
</body>
</html>
